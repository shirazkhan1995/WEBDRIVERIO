"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.elementEnabled = exports.setPluginProperties = exports.getPluginProperties = exports.find = exports.defaultTimeOuts = void 0;
const logger_1 = __importDefault(require("./logger"));
const async_wait_until_1 = require("async-wait-until");
const ora_1 = __importDefault(require("ora"));
const driver_1 = require("appium/driver");
let map = new Map();
exports.defaultTimeOuts = {
    timeout: 10000,
    intervalBetweenAttempts: 500,
    excludeEnabledCheck: [],
};
function find(driver, args) {
    return __awaiter(this, void 0, void 0, function* () {
        const session = driver.sessionId;
        let timeoutProp = _getPluginProperties(session) || exports.defaultTimeOuts;
        const locatorArgs = JSON.parse(JSON.stringify(args));
        const strategy = locatorArgs[0];
        const selector = locatorArgs[1];
        const sessionInformation = sessionInfo(driver);
        const predicate = () => __awaiter(this, void 0, void 0, function* () {
            if (_getAutomationName(driver) === 'Fake') {
                try {
                    const element = yield driver.findElement(strategy, selector);
                    return {
                        value: {
                            ELEMENT: element.ELEMENT,
                        },
                    };
                }
                catch (e) {
                    return false;
                }
            }
            else {
                const ele = yield elementState(sessionInformation, strategy, selector, driver);
                if (ele.value.error === undefined) {
                    return ele;
                }
                else {
                    return false;
                }
            }
        });
        let spinner;
        try {
            spinner = (0, ora_1.default)(`Waiting to find element with ${strategy} strategy for ${selector} selector`).start();
            const element = yield (0, async_wait_until_1.waitUntil)(predicate, timeoutProp);
            logger_1.default.info(`Element with ${strategy} strategy for ${selector} selector found.`);
            let elementViewState = yield elementIsDisplayed(driver, element.value.ELEMENT);
            if (elementViewState)
                logger_1.default.info('Element is displayed!');
            if (!elementViewState)
                throw new driver_1.errors.ElementNotVisibleError('Element was not displayed! Please make sure the element is in viewport to perform the action');
            spinner.succeed();
        }
        catch (e) {
            if (e instanceof async_wait_until_1.TimeoutError) {
                spinner.fail();
                throw new driver_1.errors.NoSuchElementError(`Time out after waiting for element ${selector} for ${timeoutProp.timeout} ms`);
            }
            else {
                console.error(e);
            }
        }
    });
}
exports.find = find;
function getPluginProperties(sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        return _getPluginProperties(sessionId);
    });
}
exports.getPluginProperties = getPluginProperties;
function setPluginProperties(sessionId, args) {
    return __awaiter(this, void 0, void 0, function* () {
        _setPluginProperties(args, sessionId);
    });
}
exports.setPluginProperties = setPluginProperties;
function elementEnabled(driver, el) {
    return __awaiter(this, void 0, void 0, function* () {
        let timeoutProp = _getPluginProperties(driver.sessionId);
        const predicate = () => __awaiter(this, void 0, void 0, function* () {
            const element = yield driver.elementEnabled(el);
            if (element) {
                return element;
            }
            else {
                logger_1.default.info('Waiting to find element to be enabled');
                return false;
            }
        });
        try {
            yield (0, async_wait_until_1.waitUntil)(predicate, timeoutProp);
        }
        catch (e) {
            if (e instanceof async_wait_until_1.TimeoutError) {
                throw new Error(`Time out after waiting for element to be enabled for ${timeoutProp.timeout}`);
            }
            else {
                console.error(e);
            }
        }
    });
}
exports.elementEnabled = elementEnabled;
function elementIsDisplayed(driver, element) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.default.info('Check if element is displayed');
        return yield driver.elementDisplayed(element);
    });
}
function _getAutomationName(driver) {
    return driver.caps.automationName;
}
function sessionInfo(driver) {
    if (driver.caps.automationName === 'Fake')
        return;
    const automationName = _getAutomationName(driver);
    if (automationName.toLowerCase() === 'xcuitest') {
        return {
            baseUrl: `${driver.wda.webDriverAgentUrl}`,
            jwProxySession: driver.wda.jwproxy.sessionId,
        };
    }
    else {
        return {
            baseUrl: `http://${driver.uiautomator2.jwproxy.server}:${driver.uiautomator2.jwproxy.port}/`,
            jwProxySession: driver.uiautomator2.jwproxy.sessionId,
        };
    }
}
function elementState(sessionInfo, strategy, selector, driver) {
    return __awaiter(this, void 0, void 0, function* () {
        let automationName = _getAutomationName(driver);
        let postBody;
        if (automationName.toLowerCase() === 'xcuitest') {
            postBody = JSON.stringify({
                using: strategy,
                value: selector,
            });
        }
        else {
            postBody = JSON.stringify({
                strategy,
                selector,
                context: '',
                multiple: false,
            });
        }
        const response = yield fetch(`${sessionInfo.baseUrl}session/${sessionInfo.jwProxySession}/element`, {
            body: postBody,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        });
        return yield response.json();
    });
}
function _getPluginProperties(sessionId) {
    return map.get(sessionId);
}
function _setPluginProperties(elementWaitProps, sessionId) {
    const props = _getPluginProperties(sessionId) || Object.assign({}, exports.defaultTimeOuts);
    props.timeout = elementWaitProps.timeout || props.timeout;
    props.intervalBetweenAttempts =
        elementWaitProps.intervalBetweenAttempts || props.intervalBetweenAttempts;
    props.excludeEnabledCheck = elementWaitProps.excludeEnabledCheck || props.excludeEnabledCheck;
    if (typeof props.timeout !== 'number' ||
        typeof props.intervalBetweenAttempts !== 'number' ||
        !Array.isArray(props.excludeEnabledCheck)) {
        logger_1.default.error('Plugin properties sent are not matching the expected contract');
        logger_1.default.error('Expected contract "timeout" and "intervalBetweenAttempts" should be number and excludeEnabledCheck should be array');
        logger_1.default.error(`example of expected contract ${JSON.stringify(exports.defaultTimeOuts)}`);
        logger_1.default.error(`Got ${JSON.stringify(props)}`);
        throw new Error('Wait plugin properties didnot match contract.');
    }
    map.set(sessionId, props);
    logger_1.default.info(`Timeout properties set for session ${sessionId} is ${JSON.stringify(_getPluginProperties(sessionId))}`);
}
